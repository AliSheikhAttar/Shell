
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adduser: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">asa/shell/internal/command/adduser/adduser.go (100.0%)</option>
				
				<option value="file1">asa/shell/internal/command/cat/cat.go (100.0%)</option>
				
				<option value="file2">asa/shell/internal/command/cd/cd.go (96.3%)</option>
				
				<option value="file3">asa/shell/internal/command/color/color.go (100.0%)</option>
				
				<option value="file4">asa/shell/internal/command/echo/echo.go (100.0%)</option>
				
				<option value="file5">asa/shell/internal/command/exit/exit.go (50.0%)</option>
				
				<option value="file6">asa/shell/internal/command/help/help.go (100.0%)</option>
				
				<option value="file7">asa/shell/internal/command/history/history.go (100.0%)</option>
				
				<option value="file8">asa/shell/internal/command/login/login.go (86.4%)</option>
				
				<option value="file9">asa/shell/internal/command/logout/logout.go (100.0%)</option>
				
				<option value="file10">asa/shell/internal/command/ls/ls.go (90.5%)</option>
				
				<option value="file11">asa/shell/internal/command/pwd/pwd.go (60.0%)</option>
				
				<option value="file12">asa/shell/internal/command/type/type.go (96.0%)</option>
				
				<option value="file13">asa/shell/internal/database/database.go (71.4%)</option>
				
				<option value="file14">asa/shell/internal/redirection/redirection.go (90.7%)</option>
				
				<option value="file15">asa/shell/internal/service/user.go (82.0%)</option>
				
				<option value="file16">asa/shell/internal/shell/shell.go (66.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adduser

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type AddUserCommand struct {
        db   *gorm.DB
        user *user.User
}

func NewAddUserCommand(db *gorm.DB, user *user.User) *AddUserCommand <span class="cov8" title="1">{
        return &amp;AddUserCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *AddUserCommand) Name() string <span class="cov8" title="1">{
        return "adduser"
}</span>

func (c *AddUserCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return utils.ErrUsernameRequired
        }</span>
        <span class="cov8" title="1">if len(args) &gt; 2 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">var pass string
        if len(args) == 2 </span><span class="cov8" title="1">{
                pass = args[1]
        }</span>

        <span class="cov8" title="1">newUser := &amp;user.User{Username: args[0], Password: pass}
        err := user.RegisterUser(c.db, newUser)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cat

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
)

var (
        ErrCatNoArgs = errors.New("no argument")
)

type CatCommand struct{}

func NewCatCommand() *CatCommand <span class="cov8" title="1">{
        return &amp;CatCommand{}
}</span>

func (c *CatCommand) Name() string <span class="cov8" title="1">{
        return "cat"
}</span>

func (c *CatCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return ErrCatNoArgs
        }</span>

        <span class="cov8" title="1">for _, filename := range args </span><span class="cov8" title="1">{
                if err := c.displayFile(filename, stdout); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *CatCommand) displayFile(filename string, stdout io.Writer) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                fmt.Fprintln(stdout, scanner.Text())
        }</span>

        <span class="cov8" title="1">return scanner.Err()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cd

import (
        "asa/shell/utils"
        "errors"
        "io"
        "os"
        "path/filepath"
        "strings"
)

var (
        ErrNoFileDir = errors.New("no such file or directory")
)

type CDCommand struct {
        rootDir string
}

func NewCDCommand(rootDir string) *CDCommand {
        return &amp;CDCommand{
                rootDir: rootDir,
        }
}

f</span>unc (c *CDCommand) Name() string {
        return "cd"
}

func (c *CDCommand) Execute(args []string, stdout io.Writer) error {
        </span>var dir string

        switch len(args) {
        case 0:
                dir = c.rootDir
        case 1:
                switch args[0] {</span>
                case "<span class="cov8" title="1">~":
                        dir = os.Getenv("HOME")
                default:
</span>                        dir =<span class="cov8" title="1"> args[0]
                        if len(dir) &gt; 0 &amp;&amp; dir[0] == '~' {
                                home := os.Ge</span>tenv("HOME")
                                dir = f<span class="cov8" title="1">ilepath.Join(home, dir[1:])
                                break
                        }
</span>                        if dir <span class="cov8" title="1">== ".." {
                                currentDir, err := utils.CurrentPwd()
                                if err != nil {
                                        return err
                                }
</span>                                currentCleanDir := filepath.Clean(currentDir)
                                dirArgs := strings.Split(currentCleanDir, "/")
                                dirAr</span>gs = dirArgs[:len(dirArgs)-1]
                                newDir := strings.Join(dirArgs, "/")
                        <span class="cov8" title="1">        if utils.IsVal</span><span class="cov8" title="1">idDirectory(newDir) {
                                        dir = newDir
                                        break
</span>
                                }</span>
                        }<span class="cov8" title="1">
                }
        default:
                return utils.ErrTooManyArgs
        }
</span>
        if err :=</span> os.Chdir(dir); err != nil {
                return ErrNoFileDir
        }

        return nil
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package color

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "strings"
)

type ColorCommand struct {
        envVar string
}

func NewColorCommand() *ColorCommand {
        colorCmd := &amp;ColorCommand{envVar: "SHELLCOLOR"}
        os.Setenv(colorCmd.envVar, "1")
        return colorCmd
}

f</span>unc (c *ColorCommand) Name() string {
        return "color"
}

func (c *ColorCommand) Execute(args []string, stdout io.Writer) error {
        </span>switch len(args) {
        case 0:
                return utils.ErrNotEnoughArgs
        case 1:

</span>                if str<span class="cov8" title="1">ings.ToLower(args[0]) == "off" {
                        return c.unSet(stdout)
</span>                }
                if strings.ToLower(args[0]) == "on" {
                        return c.set(stdout)
</span>                }
                r</span>eturn utils.ErrUnvalidArg
        d<span class="cov8" title="1">efault:
</span>                return utils.ErrTooManyArgs
        }
</span>}
</span>
func (c *ColorCommand) unSet(</span>stdout io.Writer) error {

        if _, ok := os.LookupEnv(c.envVar); !ok {
                return utils.ErrColorUnset
        }
        os.Unsetenv(c.envVar)
        fmt.Fprintln(stdout, "Color is set off")</span><span class="cov8" title="1">
        return nil
}
</span>f<span class="cov8" title="1">unc (c *ColorCommand) set(stdout io.Writer) error {
        if _, ok := os.LookupEnv(c.envVar); ok {
                return ut</span>ils.ErrColorSet
        }
        os.Setenv(c.envVar, "1")

</span>        fmt.Fprintln(stdout, utils.ColorText("Color is set on", utils.TextBlue))
        r</span>eturn nil
}<span class="cov8" title="1">
</pre>
		
		<pre class="file" id="file4" style="display: none">package echo

import (
        "fmt"
        "io"
        "strings"
)

type EchoCommand struct{}

func NewEchoCommand() *EchoCommand <span class="cov8" title="1">{
        return &amp;EchoCommand{}
}</span>

func (c *EchoCommand) Name() string <span class="cov8" title="1">{
        return "echo"
}</span>

func (c *EchoCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        output := strings.Join(args, " ")
        fmt.Fprintln(stdout, output)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package exit

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "strconv"

        "gorm.io/gorm"
)

type ExitCommand struct {
        user *user.User
        db   *gorm.DB
}

func NewExitCommand(db *gorm.DB, user *user.User) *ExitCommand {
        return &amp;ExitCommand{
                user: user,
                db:   db,
        }
}

f</span>unc (c *ExitCommand) Name() string {
        return "exit"
}

func (c *ExitCommand) Execute(args []string, stdout io.Writer) error {

</span>        switch len(args) {
        case 0:
                if c.user.Username != "" {
                        user.Update(c.db, c.user)
                }
</span>                fmt.Fp<span class="cov0" title="0">rintln(stdout, "exit status 0")
                os.Exit(0)
</span>
        ca</span>se 1:
                <span class="cov0" title="0">if c.user.Username != "" {
                        user.Upda</span>te(c.db, c.user)
                }
                status<span class="cov8" title="1">, err := strconv.Atoi(args[0])
                if err != nil {
</span>                        return utils.ErrInvalidArgs
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(stdout, "exit status ", status)
                os.Exit(0)
</span>        default:
                r</span>eturn utils.ErrTooManyArgs
        }<span class="cov0" title="0">
        return nil
</span>}
</pre>
		
		<pre class="file" id="file6" style="display: none">package help

import (
        "asa/shell/utils"
        "fmt"
        "io"
)

type HelpCommand struct {
}

func NewHelpCommand() *HelpCommand <span class="cov8" title="1">{
        return &amp;HelpCommand{}
}</span>

func (c *HelpCommand) Name() string <span class="cov8" title="1">{
        return "help"
}</span>

func (c *HelpCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        commands := map[string][2]string{
        <span class="cov8" title="1">        
                "cd":      {"change your directory", "cd &lt;path&gt;"},
                "ls":      {"see the content of the directory", "ls [options]"},
                "cat":     {"see the content of the files", "cat &lt;filename&gt;"},
                "pwd":     {"current directory path", "pwd"},
                "type":    {"type of a command", "type &lt;command&gt;"},
                "adduser": {"register user to shell", "adduser {username} {password | empty}"},
                "echo":    {"write text/variables to output", "echo &lt;text&gt;"},
                "login":   {"login to shell as user", "login {username} {password | empty}"},
                "logout":  {"logout the shell", "logout"},
                "exit":    {"exit the shell", "exit [status code]"},
                "color":   {"set on/off color mode", "color [on|off]"},
                "history": {"history of executed commands", "history | history clean"},
        }

        fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        coloredCommand := utils.ColorText("Command", utils.TextBlue, utils.Bold)
        coloredDescription := utils.ColorText("Description", utils.TextBlue, utils.Bold)
        coloredUsage := utils.ColorText("Usage", utils.TextBlue, utils.Bold)
        fmt.Fprintf(stdout, "|   %s   |             %s           |           %s                       |\n", coloredCommand, coloredDescription, coloredUsage)
        fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        for key, val := range commands {
                coloredKey := utils.ColorText(key, utils.TextYellow)
                fmt.Fprintf(stdout, "| %-20s | %-42s | %-46s |\n", coloredKey, utils.ColorText(val[0], utils.TextMagenta), utils.ColorText(val[1], utils.TextCyan))
        }
</span>        fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        return nil
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package history

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type HistoryCommand struct {
        builtinHistory *map[string]int
        user           *user.User
        db             *gorm.DB
}

func NewHistoryCommand(builtinHistory *map[string]int, user *user.User, db *gorm.DB) *HistoryCommand <span class="cov8" title="1">{
        return &amp;HistoryCommand{
                builtinHistory: builtinHistory,
                user:           user,
                db:             db,
        }
}</span>

func (h *HistoryCommand) Name() string <span class="cov8" title="1">{
        return "history"
}</span>

func (h *HistoryCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">if len(args) == 1 </span><span class="cov8" title="1">{
                if args[0] != "clean" </span><span class="cov8" title="1">{
                        return utils.ErrInvalidArgs
                }</span>
                <span class="cov8" title="1">if h.user.Username != "" </span><span class="cov8" title="1">{
                        h.user.HistoryMap = map[string]int{}
                        err := user.Update(h.db, h.user)
                        return err
                }</span>
                <span class="cov8" title="1">*h.builtinHistory = map[string]int{}
                return nil</span>
        }
        <span class="cov8" title="1">if h.user.Username != "" </span><span class="cov8" title="1">{
                if len(h.user.HistoryMap) == 0 </span><span class="cov8" title="1">{
                        return utils.ErrEmptyHistory
                }</span>
                <span class="cov8" title="1">utils.PrintSortedMap(h.user.HistoryMap, stdout)
                return nil</span>
        }
        <span class="cov8" title="1">if len(*h.builtinHistory) == 0 </span><span class="cov8" title="1">{
                return utils.ErrEmptyHistory
        }</span>
        <span class="cov8" title="1">utils.PrintSortedMap(*h.builtinHistory, stdout)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package login

import (
        userService "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type LoginCommand struct {
        db   *gorm.DB
        user *userService.User
}

func NewLoginCommand(db *gorm.DB, user *userService.User) *LoginCommand <span class="cov8" title="1">{
        return &amp;LoginCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *LoginCommand) Name() string <span class="cov8" title="1">{
        return "login"
}</span>

func (c *LoginCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        // if (*c.user).Username != "" {
        //         return ErrLoggedin
        // }
        if len(args) == 0 </span><span class="cov8" title="1">{
                return utils.ErrUsernameRequired
        }</span>
        <span class="cov8" title="1">if len(args) &gt; 2 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">var pass string
        if len(args) == 2 </span><span class="cov8" title="1">{
                pass = args[1]
        }</span>
        <span class="cov8" title="1">user, err := userService.GetUser(c.db, args[0], pass)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if c.user.Username != "" </span><span class="cov0" title="0">{
                err := userService.Update(c.db, c.user)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">(*c.user).ID = user.ID
        (*c.user).Username = user.Username
        (*c.user).Password = user.Password
        (*c.user).History = user.History
        (*c.user).HistoryMap = user.HistoryMap

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package logout

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type LogoutCommand struct {
        db   *gorm.DB
        user *user.User
}

func NewLogoutCommand(db *gorm.DB, user *user.User) *LogoutCommand <span class="cov8" title="1">{
        return &amp;LogoutCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *LogoutCommand) Name() string <span class="cov8" title="1">{
        return "logout"
}</span>

func (c *LogoutCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>

        <span class="cov8" title="1">err := user.Update(c.db, c.user)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">(*c.user).ID = 0
        (*c.user).Username = ""
        (*c.user).Password = ""

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ls

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "io/fs"
        "os"
        "strings"
        "time"
)

type LSCommand struct {
        showAll    bool
        longFormat bool
}

func NewLSCommand() *LSCommand {
        return &amp;LSCommand{}
}

f</span>unc (c *LSCommand) Name() string {
        return "ls"
}

func (c *LSCommand) Execute(args []string, stdout io.Writer) error {
        </span>dirPath, err := c.parseArgs(args)
        if err != nil {
                return err
        }

        if dirPath == "" {
                dirPath = "."</span><span class="cov8" title="1">
        }

</span>        return c.listDirectory(dirPath, stdout)
}

</span>func (c *LSCommand) parseArgs(args []string) (string, error) {
        v</span>ar dirPath string
        c.showAll = false
        <span class="cov8" title="1">c.longFormat = false
</span>        for _, arg := range args {
                if strings.HasPrefix(arg, "-") {
                        for _, opt := range arg[1:] {
                                switch opt {
                                case 'a':
                                        c.showAll = true
                                case 'l':
                                        c.longFormat = true
</span>                                default:
</span>                                        return "", fmt.Errorf("invalid option: %c", opt)
                                }
</span>                        }
</span>                } else {
                        if dirPath != "" {</span>
                                return ""<span class="cov8" title="1">, utils.ErrTooManyArgs
                        }
</span>                        dirPath =<span class="cov8" title="1"> arg
                }
</span>        }

        return <span class="cov8" title="1">dirPath, nil
}

</span>func (c *LSCommand) listDirectory(dirPath string, stdout io.Writer) error {
        ent</span>ries, err := os.ReadDir(dirPath)
        if<span class="cov8" title="1"> err != nil {</span>
                return fmt.Errorf("cannot open directory %s: %v", dirPath, err)
        }

        <span class="cov8" title="1">for _, entry := ran</span>ge entries {
                if !c.showAll &amp;&amp; strings.HasPrefix(entry.Name(), ".") {
                        continue
                }

                if c.longFormat {
                        if err := c.</span><span class="cov8" title="1">printLongFormat(entry, stdout); err != nil {
                                return err
                </span>        }
                } else {
                        fmt.Fprintln(stdout, entry.Name())
        <span class="cov8" title="1">        }
</span>        }

</span>        return nil</span>
}

fu<span class="cov8" title="1">nc (c *LSCommand</span><span class="cov8" title="1">) printLongFormat(entry fs.DirEntry, stdout io.Writer) error {
        info, err := entry.Info()
</span>        if err != nil {
                re</span>turn fmt.Errorf("error getting info for %s: %v", entry.Name(), err)
        }

        mo</span>de := info.Mode().String()
        size := info.Size()
        modTime := info.ModTime().Format(time.RFC3339[:19]) // Use shorter time format
        <span class="cov8" title="1">name := en</span>try.Name()
        fmt.Fprintf(stdout, "%s %8d %s %s\n", mode, size, modTime, name)
        return nil
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package pwd

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
)

type PwdCommand struct{}

func NewPwdCommand() *PwdCommand {
        return &amp;PwdCommand{}
}

</span>func (c *PwdCommand) Execute(args []string, stdout io.Writer) error {
        pwd, err := c.getCurrentDirectory()
        if err != nil {
                return fmt.Er</span><span class="cov0" title="0">rorf("failed to get current directory: %v", err)
        }

</span>        _, err = fmt.Fprintln(stdout, pwd)
        <span class="cov8" title="1">return err
}
</span>
func (c *PwdCommand) getCurrentDirectory() (string, error) {

        if pwd, err := filepath.Abs("."); pwd != "" &amp;&amp; err == nil {
                if utils.IsValidDirectory(pwd) {
</span>                        return filepath.Clean(pwd), ni</span><span class="cov8" title="1">l
                }
        }
</span>        // Try /proc/self/cwd on Linux
        if runtime.GOOS == "linux" {
        <span class="cov0" title="0">        if pwd, err := os.Readlink</span><span class="cov0" title="0">("/proc/self/cwd"); err == nil {
                        if utils.IsValidDirectory(pwd) {
</span>                                return filepath.Clean(pwd), ni</span><span class="cov0" title="0">l
                        }
                }
</span>        }
        return "", nil
}<span class="cov0" title="0">
</span>
func (c *PwdCommand) Name() string {
        return "pwd"
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package typecmd

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

type TypeCommand struct {
        builtins map[string]bool 
}

func NewTypeCommand(builtins []string) *TypeCommand <span class="cov8" title="1">{
        builtinsMap := make(map[string]bool)
        for _, cmd := range builtins {
                builtinsMap[cmd] = true
</span>        }

</span>        return &amp;TypeCommand{
        <span class="cov8" title="1">        builtins: builtinsMap,
        }
}
</span>
func (c *TypeCommand) Name() string {
        return "type"
}

</span>func (c *TypeCommand) Execute(args []string, stdout io.Writer) error {
        if len(args) == 0 {
                return utils.ErrM</span><span class="cov8" title="1">issingCommandName
        }
        f</span>or _, cmd := range args {
        <span class="cov8" title="1">        result, err := c.findCom</span><span class="cov8" title="1">mand(cmd)
                if err != nil {
                        return err
</span>                }
                f</span>mt.Fprintln(stdout, result)
        }<span class="cov8" title="1">
</span>
        return nil
}<span class="cov8" title="1">
</span>
func (c *TypeCommand) findCommand(cmd string) (string, error) {
        if c.builtins[cmd] {
                return fmt.Sprintf("%s is a shell builtin", cmd), nil
        }
</span>
        p</span>ath := os.Getenv("PATH")
        if path == "" {
                return "", utils.ErrEnvironmentVarNotSet
        <span class="cov8" title="1">}

</span>        dirs := strings.Split(path, ":")
        f</span>or _, dir := range dirs {
                fullPath := filepath.Join(dir, cmd)
                if fileInfo, err := os.Stat(fullPath); err == nil {
        <span class="cov8" title="1">                if fileInfo.Mode()&amp;0111 != 0 {

</span>                                return fmt.Sprintf("%s is %s", cmd, fullPath), nil
                        }
</span>                }
        }
</span>
        return "", utils.ErrCommandNotFound
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "fmt"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

const (
        dbHost = "localhost"
        dbPort = "5432"
        dbName = "postgres"
        dbUser = "postgres"
        dbPass = "postgres"
)

var db *gorm.DB

func init() <span class="cov8" title="1">{
        dsn := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
                dbHost, dbPort, dbName, dbUser, dbPass)

        sesssion, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)})
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("unable to connect to database: %w", err)
                panic(err)</span>
        }

        <span class="cov8" title="1">db = sesssion</span>

}

func GetDB() *gorm.DB <span class="cov8" title="1">{
        return db
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package redirection

import (
        "fmt"
        "os"
)

type RedirectionType int

var (
        ErrMissingFileForRedirection = fmt.Errorf("missing file for redirection")
)

const (
        NoRedirection  RedirectionType = iota
        OutputRedirect                 // &gt;
        OutputAppend                   // &gt;&gt;
        ErrorRedirect                  // 2&gt;
        ErrorAppend                    // 2&gt;&gt;
)

type Redirection struct {
        Type RedirectionType
        File string
}

func ParseRedirection(args []string) ([]string, *Redirection, error) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args, nil, nil
        }</span>
        <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                switch </span>{
                case arg == "&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov8" title="1">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: OutputRedirect,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: OutputRedirect,
                                File: args[i+1],
                        }, nil</span>

                case arg == "&gt;&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: OutputAppend,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: OutputAppend,
                                File: args[i+1],
                        }, nil</span>

                case arg == "2&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: ErrorRedirect,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: ErrorRedirect,
                                File: args[i+1],
                        }, nil</span>

                case arg == "2&gt;&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: ErrorAppend,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: ErrorAppend,
                                File: args[i+1],
                        }, nil</span>
                }
        }

        <span class="cov8" title="1">return args, nil, nil</span>
}

func SetupRedirection(redir *Redirection) (*os.File, error) <span class="cov8" title="1">{
        if redir == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">flags := os.O_WRONLY | os.O_CREATE
        if redir.Type == OutputAppend || redir.Type == ErrorAppend </span><span class="cov8" title="1">{
                flags |= os.O_APPEND
        }</span> else<span class="cov8" title="1"> {
                flags |= os.O_TRUNC
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile(redir.File, flags, 0644)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open redirection file: %v", err)
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        "encoding/json"
        "errors"
        "fmt"

        "gorm.io/gorm"
)

var (
        ErrNoUserFound      = errors.New("no user found")
        ErrUserShouldntNill = errors.New("user cannot be nil")
        ErrUserNameRequired = errors.New("username is required")
        ErrWrongPassword    = errors.New("wrong password")
        ErrDuplicateUser    = errors.New("duplicate user exists with this username")
        ErrUserNotFound     = errors.New("user not found")
        ErrPassRequired     = errors.New("password required")
)

func RegisterUser(db *gorm.DB, user *User) error <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                return errors.New("user cannot be nil")
        }</span>

        <span class="cov8" title="1">if err := validate(user); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">var existingUser User
        err := db.Where("user_name = ?", user.Username).First(&amp;existingUser).Error
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                return ErrDuplicateUser
        }</span>

        <span class="cov8" title="1">historyMap := map[string]int{}

        historyJSON, err := json.Marshal(historyMap)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode history to JSON: %w", err)
        }</span>
        <span class="cov8" title="1">user.History = string(historyJSON)

        if err := db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert user into database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetUser(db *gorm.DB, username string, password string) (User, error) <span class="cov8" title="1">{
        var user User
        if err := db.Where("user_name = ? ", username).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return user, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return user, err</span>
        }
        <span class="cov8" title="1">if user.Password != "" &amp;&amp; user.Password != password </span><span class="cov8" title="1">{
                if password == "" </span><span class="cov8" title="1">{
                        return user, ErrPassRequired
                }</span>
                <span class="cov8" title="1">return user, ErrWrongPassword</span>
        }

        <span class="cov8" title="1">var historyMap map[string]int
        err := json.Unmarshal([]byte(user.History), &amp;historyMap)
        if err != nil </span><span class="cov0" title="0">{
                historyMap = map[string]int{}
                user.HistoryMap = historyMap
                return user, err
        }</span>
        <span class="cov8" title="1">user.HistoryMap = historyMap

        return user, nil</span>
}

func Update(db *gorm.DB, user *User) (err error) <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                return ErrUserShouldntNill
        }</span>
        <span class="cov8" title="1">if err := validate(user); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation error: %w", err)
        }</span>
        <span class="cov8" title="1">historyJSON, err := json.Marshal(user.HistoryMap)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode history to JSON: %w", err)
        }</span>
        <span class="cov8" title="1">user.History = string(historyJSON)
        err = db.Save(user).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user in database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validate(user *User) (err error) <span class="cov8" title="1">{
        if user.Username == "" </span><span class="cov8" title="1">{
                return ErrUserNameRequired
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package shell

import (
        "asa/shell/internal/command"
        "asa/shell/internal/command/adduser"
        "asa/shell/internal/command/cat"
        "asa/shell/internal/command/cd"
        "asa/shell/internal/command/color"
        "asa/shell/internal/command/echo"
        "asa/shell/internal/command/exit"
        "asa/shell/internal/command/help"
        "asa/shell/internal/command/history"
        "asa/shell/internal/command/login"
        "asa/shell/internal/command/logout"
        "asa/shell/internal/command/ls"
        "asa/shell/internal/command/pwd"
        typecmd "asa/shell/internal/command/type"
        db "asa/shell/internal/database"
        "asa/shell/internal/redirection"
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strings"

        "gorm.io/gorm"
)

var (
        ErrCommandNotSupported = errors.New("command not found")
        ErrNotValidDirectory   = errors.New("current directory is not valid")
)

type Shell struct {
        reader   *bufio.Reader
        user     user.User
        database *gorm.DB
        commands map[string]command.Command
        history  map[string]int
        rootDir  string
}

type std struct {
        std          *os.File
        isRedirected bool
}
type redirect struct {
        stdout    *std
        stderr    *std
        redirType redirection.RedirectionType
}

func New() *Shell <span class="cov8" title="1">{
        rootDir, err := utils.CurrentPwd()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Shell{}
        }</span>

        <span class="cov8" title="1">err = db.GetDB().AutoMigrate(&amp;user.User{})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error migrating database:", err)
        }</span>

        <span class="cov8" title="1">sh := &amp;Shell{
                user:     user.User{Username: ""},
                database: db.GetDB(),
                reader:   bufio.NewReader(os.Stdin),
                commands: make(map[string]command.Command),
                history:  make(map[string]int),
                rootDir:  rootDir,
        }
        exitCmd := exit.NewExitCommand(sh.database, &amp;sh.user)
        sh.registerCommand(exitCmd)

        echoCmd := echo.NewEchoCommand()
        sh.registerCommand(echoCmd)

        catCmd := cat.NewCatCommand()
        sh.registerCommand(catCmd)

        pwdCmd := pwd.NewPwdCommand()
        sh.registerCommand(pwdCmd)

        cdCmd := cd.NewCDCommand(sh.rootDir)
        sh.registerCommand(cdCmd)

        lsCmd := ls.NewLSCommand()
        sh.commands[lsCmd.Name()] = lsCmd

        colorCmd := color.NewColorCommand()
        sh.commands[colorCmd.Name()] = colorCmd

        loginCmd := login.NewLoginCommand(sh.database, &amp;sh.user)
        sh.commands[loginCmd.Name()] = loginCmd

        adduserCmd := adduser.NewAddUserCommand(sh.database, &amp;sh.user)
        sh.commands[adduserCmd.Name()] = adduserCmd

        logoutCmd := logout.NewLogoutCommand(sh.database, &amp;sh.user)
        sh.commands[logoutCmd.Name()] = logoutCmd

        historyCmd := history.NewHistoryCommand(&amp;sh.history, &amp;sh.user, sh.database)
        sh.commands[historyCmd.Name()] = historyCmd

        helpCmd := help.NewHelpCommand()
        sh.commands[helpCmd.Name()] = helpCmd

        shellBuiltins := []string{}
        for cmd := range sh.commands </span><span class="cov8" title="1">{
                shellBuiltins = append(shellBuiltins, cmd)
        }</span>
        <span class="cov8" title="1">typeCmd := typecmd.NewTypeCommand(shellBuiltins)
        sh.registerCommand(typeCmd)

        stdout := &amp;bytes.Buffer{}
        sh.commands["pwd"].Execute([]string{}, stdout)
        sh.rootDir = stdout.String()

        // if err := utils.ClearAndFillHistoryWithMockData(sh.database); err != nil {
        //         log.Fatalf("Error clearing and filling history: %v", err)
        // }
        return sh</span>
}

func (s *Shell) registerCommand(cmd command.Command) <span class="cov8" title="1">{
        s.commands[cmd.Name()] = cmd
}</span>

func (s *Shell) Start() error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err := s.printPrompt(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">input, err := s.readInput()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if stderr, err := s.executeCommand(input); err != nil </span><span class="cov0" title="0">{
                        if stderr.isRedirected </span><span class="cov0" title="0">{
                                defer stderr.std.Close()
                        }</span>
                        <span class="cov0" title="0">cmdError := fmt.Sprintf("%s: %v\n", input, err)
                        if utils.IsColor() </span><span class="cov0" title="0">{
                                cmdError = utils.ColorText(cmdError, utils.TextRed)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(stderr.std, "%s", cmdError)
                        if err == ErrCommandNotSupported </span><span class="cov0" title="0">{
                                fmt.Println()
                                fmt.Fprintln(stderr.std, "List of supported builtin commands are as followings: ")
                                for key := range s.commands </span><span class="cov0" title="0">{
                                        fmt.Fprintln(stderr.std, key)
                                }</span>
                        }
                }
        }
}

func (s *Shell) printPrompt() error {
        currentDir, err := utils.CurrentPwd<span class="cov0" title="0">()
        if err != nil {
                return err
</span>        }
        a</span>ddr := utils.HandleAdress(s.rootDir, currentDir)
        <span class="cov0" title="0">user := s.user.Username
        if utils.IsColor() {
                addr = utils.Color</span><span class="cov0" title="0">Text(addr, utils.TextBlue)
                user = utils.ColorText(s.user.Username, utils.TextGreen)
        }
        i</span>f s.user.Username != "" {
        <span class="cov0" title="0">        _, err = fmt.Fprintf(os.</span><span class="cov0" title="0">Stdout, "%s:%s$ ", user, addr)
        } else {
                </span>_, er<span class="cov0" title="0">r = fmt.Fprintf(os.Stdout, "%s$ ", addr)
        }
        r</span>eturn err
}<span class="cov0" title="0">
</span>
func (s *Shell) readInput() (string, error) {
        input, err := s.reader.ReadString('\n')
        if err != nil {
                return "", er</span><span class="cov0" title="0">r
        }
        r</span>eturn strings.TrimSpace(input), nil
}<span class="cov8" title="1">
</span>
func (s *Shell) executeCommand(input string) (*std, error) {
        cmd, args, redirects, err := s.parseCommand(input)
        if cmd != "history" {
                if s.user.Username </span><span class="cov8" title="1">!= "" {
                        s.user.HistoryMap[input]</span><span class="cov0" title="0">++
                        // err := user.Update(s.database, &amp;s.user)
                } else {
                        </span>s.his<span class="cov8" title="1">tory[input]++
                }
        }
</span>
        if err != nil {
        <span class="cov8" title="1">        return redire</span><span class="cov0" title="0">cts.stderr, err
        }

</span>        if redirects.stdout.isRedirected {

</span>                defer redirects.stdout.std.Close()
        }

</span>        if command, exists := s.commands[cmd]; exists {
        <span class="cov8" title="1">        err := command.Execute(args, redirects.stdout</span><span class="cov8" title="1">.std)
                if err != nil {
                        return redire</span><span class="cov0" title="0">cts.stderr, err
                }
                r</span>eturn redirects.stderr, nil
        }<span class="cov8" title="1">
</span>
        if err := s.executeSystemCommand(cmd, args, redirects.stdout.std, redirects.stderr.std); err != nil {
        <span class="cov8" title="1">        return redirects.stderr, ErrCommandNotSupported
</span>        }

</span>        return redirects.stderr, nil
}<span class="cov8" title="1">
</span>
func (s *Shell) executeSystemCommand(name string, args []string, stdout io.Writer, stderr io.Writer) error {
        execPath, err := utils.FindCommand(name)
        if err != nil {
                return err
</span>        }
        i</span>f utils.HasPrefix(execPath, "$builtin") {
        <span class="cov8" title="1">        execPath = strings.Split(execPath, ":")[</span><span class="cov0" title="0">1]
        }

</span>        cmd := exec.Command(execPath, args...)

        cmd.Stdout = stdout
        cmd.Stderr = stderr

        err = cmd.Run()
        if err != nil {
                return fmt.Er</span><span class="cov8" title="1">rorf("failed to execute %s: %v", name, err)
        }

</span>        return nil
}<span class="cov8" title="1">
</span>
func (s *Shell) parseCommand(input string) (string, []string, *redirect, error) {
        redirects := &amp;redirect{stdout: &amp;std{os.Stdout, false}, stderr: &amp;std{os.Stderr, <span class="cov8" title="1">false}}
        parsedArg, err1 := utils.ParseArgs(input)
        if err1 != nil {
                return "", nil</span><span class="cov0" title="0">, redirects, nil
        }
        i</span>f len(parsedArg) == 0 {
        <span class="cov8" title="1">        return "", nil, redire</span><span class="cov8" title="1">cts, nil
        }
        a</span>rgs, redir, err := redirection.ParseRedirection(parsedArg)
        if err != nil {
        <span class="cov8" title="1">        return "", nil, redirects, err
        }
</span>        if redir != nil {
                </span>file, err := redirection.SetupRedirection(redir)
                if err != nil {
        <span class="cov8" title="1">                return "", nil</span><span class="cov8" title="1">, redirects, err
                }
                switch redir.T</span><span class="cov0" title="0">ype {
                case redirection.OutputRedirect, redirection.OutputAppend:
                        </span>redirects.stdout.std = file
                        redirects.stdout.isRedirected = true
                <span class="cov8" title="1">case redirection.E</span>rrorRedirect, redirection.ErrorAppend:
                        redirects.stderr.std = file
                        redirects.stderr.isRedirected = true
                }
</span>                redirects.redirType = redir.Type
        }
        // for case : &gt; file3 cat file2
</span>        if parsedArg[0][0] != '&gt;' {
                <span class="cov8" title="1">return parsedArg[0], args[1:], r</span>edirects, err1
        } else {
                return parsedArg[2], args, redirects, err1
        <span class="cov8" title="1">}
</span>}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
