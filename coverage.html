
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adduser: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">asa/shell/internal/command/adduser/adduser.go (100.0%)</option>
				
				<option value="file1">asa/shell/internal/command/cat/cat.go (100.0%)</option>
				
				<option value="file2">asa/shell/internal/command/cd/cd.go (96.3%)</option>
				
				<option value="file3">asa/shell/internal/command/color/color.go (100.0%)</option>
				
				<option value="file4">asa/shell/internal/command/echo/echo.go (100.0%)</option>
				
				<option value="file5">asa/shell/internal/command/exit/exit.go (50.0%)</option>
				
				<option value="file6">asa/shell/internal/command/help/help.go (100.0%)</option>
				
				<option value="file7">asa/shell/internal/command/history/history.go (100.0%)</option>
				
				<option value="file8">asa/shell/internal/command/login/login.go (86.4%)</option>
				
				<option value="file9">asa/shell/internal/command/logout/logout.go (100.0%)</option>
				
				<option value="file10">asa/shell/internal/command/ls/ls.go (90.5%)</option>
				
				<option value="file11">asa/shell/internal/command/pwd/pwd.go (60.0%)</option>
				
				<option value="file12">asa/shell/internal/command/type/type.go (96.0%)</option>
				
				<option value="file13">asa/shell/internal/database/database.go (71.4%)</option>
				
				<option value="file14">asa/shell/internal/redirection/redirection.go (90.7%)</option>
				
				<option value="file15">asa/shell/internal/service/user.go (82.0%)</option>
				
				<option value="file16">asa/shell/internal/shell/shell.go (66.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adduser

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type AddUserCommand struct {
        db   *gorm.DB
        user *user.User
}

func NewAddUserCommand(db *gorm.DB, user *user.User) *AddUserCommand <span class="cov8" title="1">{
        return &amp;AddUserCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *AddUserCommand) Name() string <span class="cov8" title="1">{
        return "adduser"
}</span>

func (c *AddUserCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return utils.ErrUsernameRequired
        }</span>
        <span class="cov8" title="1">if len(args) &gt; 2 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">var pass string
        if len(args) == 2 </span><span class="cov8" title="1">{
                pass = args[1]
        }</span>

        <span class="cov8" title="1">newUser := &amp;user.User{Username: args[0], Password: pass}
        err := user.RegisterUser(c.db, newUser)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cat

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
)

var (
        ErrCatNoArgs = errors.New("no argument")
)

type CatCommand struct{}

func NewCatCommand() *CatCommand <span class="cov8" title="1">{
        return &amp;CatCommand{}
}</span>

func (c *CatCommand) Name() string <span class="cov8" title="1">{
        return "cat"
}</span>

func (c *CatCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return ErrCatNoArgs
        }</span>

        <span class="cov8" title="1">for _, filename := range args </span><span class="cov8" title="1">{
                if err := c.displayFile(filename, stdout); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *CatCommand) displayFile(filename string, stdout io.Writer) error <span class="cov8" title="1">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                fmt.Fprintln(stdout, scanner.Text())
        }</span>

        <span class="cov8" title="1">return scanner.Err()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cd

import (
        "asa/shell/utils"
        "errors"
        "io"
        "os"
        "path/filepath"
        "strings"
)

var (
        ErrNoFileDir = errors.New("no such file or directory")
)

// CDCommand implements the 'cd' built-in command
type CDCommand struct {
        rootDir string
}

// NewCDCommand creates a new cd command
func NewCDCommand(rootDir string) *CDCommand <span class="cov8" title="1">{
        return &amp;CDCommand{
                rootDir: rootDir,
        }
}</span>

// Name returns the name of the command
func (c *CDCommand) Name() string <span class="cov8" title="1">{
        return "cd"
}</span>

// Execute handles the cd command execution
func (c *CDCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        var dir string

        switch len(args) </span>{
        case 0:<span class="cov8" title="1">
                // cd without arguments - go to home directory
                dir = c.rootDir</span>
        case 1:<span class="cov8" title="1">
                // cd with one argument
                switch args[0] </span>{
                case "~":<span class="cov8" title="1">
                        // cd ~ - go to home directory
                        dir = os.Getenv("HOME")</span>
                default:<span class="cov8" title="1">
                        // cd &lt;path&gt; - go to specified directory
                        dir = args[0]
                        // Handle relative paths that start with ~
                        if len(dir) &gt; 0 &amp;&amp; dir[0] == '~' </span><span class="cov8" title="1">{
                                home := os.Getenv("HOME")
                                dir = filepath.Join(home, dir[1:])
                                break</span>
                        }
                        <span class="cov8" title="1">if dir == ".." </span><span class="cov8" title="1">{
                                currentDir, err := utils.CurrentPwd()
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">currentCleanDir := filepath.Clean(currentDir)
                                dirArgs := strings.Split(currentCleanDir, "/")
                                dirArgs = dirArgs[:len(dirArgs)-1]
                                newDir := strings.Join(dirArgs, "/")
                                if utils.IsValidDirectory(newDir) </span><span class="cov8" title="1">{
                                        dir = newDir
                                        break</span>

                                }
                        }
                }
        default:<span class="cov8" title="1">
                return utils.ErrTooManyArgs</span>
        }

        // Try to change directory
        <span class="cov8" title="1">if err := os.Chdir(dir); err != nil </span><span class="cov8" title="1">{
                return ErrNoFileDir
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package color

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "strings"
)

// CDCommand implements the 'cd' built-in command
type ColorCommand struct {
        envVar string
}

// NewCDCommand creates a new cd command
func NewColorCommand() *ColorCommand <span class="cov8" title="1">{
        colorCmd := &amp;ColorCommand{envVar: "SHELLCOLOR"}
        os.Setenv(colorCmd.envVar, "1")
        return colorCmd
}</span>

// Name returns the name of the command
func (c *ColorCommand) Name() string <span class="cov8" title="1">{
        return "color"
}</span>

// Execute handles the cd command execution
func (c *ColorCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        switch len(args) </span>{
        case 0:<span class="cov8" title="1">
                return utils.ErrNotEnoughArgs</span>
        case 1:<span class="cov8" title="1">

                if strings.ToLower(args[0]) == "off" </span><span class="cov8" title="1">{
                        return c.unSet(stdout)
                }</span>
                <span class="cov8" title="1">if strings.ToLower(args[0]) == "on" </span><span class="cov8" title="1">{
                        return c.set(stdout)
                }</span>
                <span class="cov8" title="1">return utils.ErrUnvalidArg</span>
        default:<span class="cov8" title="1">
                return utils.ErrTooManyArgs</span>
        }
}

func (c *ColorCommand) unSet(stdout io.Writer) error <span class="cov8" title="1">{

        if _, ok := os.LookupEnv(c.envVar); !ok </span><span class="cov8" title="1">{
                return utils.ErrColorUnset
        }</span>
        <span class="cov8" title="1">os.Unsetenv(c.envVar)
        fmt.Fprintln(stdout, "Color is set off")
        return nil</span>
}
func (c *ColorCommand) set(stdout io.Writer) error <span class="cov8" title="1">{
        if _, ok := os.LookupEnv(c.envVar); ok </span><span class="cov8" title="1">{
                return utils.ErrColorSet
        }</span>
        <span class="cov8" title="1">os.Setenv(c.envVar, "1")

        fmt.Fprintln(stdout, utils.ColorText("Color is set on", utils.TextBlue))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package echo

import (
        "fmt"
        "io"
        "strings"
)

type EchoCommand struct{}

func NewEchoCommand() *EchoCommand <span class="cov8" title="1">{
        return &amp;EchoCommand{}
}</span>

func (c *EchoCommand) Name() string <span class="cov8" title="1">{
        return "echo"
}</span>

func (c *EchoCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        output := strings.Join(args, " ")
        fmt.Fprintln(stdout, output)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package exit

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "strconv"

        "gorm.io/gorm"
)

// ExitCommand implements the 'exit' built-in command
type ExitCommand struct {
        user *user.User
        db   *gorm.DB
}

// NewExitCommand creates a new exit command
func NewExitCommand(db *gorm.DB, user *user.User) *ExitCommand <span class="cov8" title="1">{
        return &amp;ExitCommand{
                user: user,
                db:   db,
        }
}</span>

// Name returns the name of the command
func (c *ExitCommand) Name() string <span class="cov8" title="1">{
        return "exit"
}</span>

// Execute handles the exit command execution
func (c *ExitCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{

        switch len(args) </span>{
        case 0:<span class="cov0" title="0">
                if c.user.Username != "" </span><span class="cov0" title="0">{
                        user.Update(c.db, c.user)
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(stdout, "exit status 0")
                os.Exit(0)</span>

        case 1:<span class="cov8" title="1">
                if c.user.Username != "" </span><span class="cov0" title="0">{
                        user.Update(c.db, c.user)
                }</span>
                <span class="cov8" title="1">status, err := strconv.Atoi(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        return utils.ErrInvalidArgs
                }</span>
                <span class="cov0" title="0">fmt.Fprintln(stdout, "exit status ", status)
                os.Exit(0)</span>
        default:<span class="cov8" title="1">
                return utils.ErrTooManyArgs</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package help

import (
        "asa/shell/utils"
        "fmt"
        "io"
)

type HelpCommand struct {
}

func NewHelpCommand() *HelpCommand <span class="cov8" title="1">{
        return &amp;HelpCommand{}
}</span>

func (c *HelpCommand) Name() string <span class="cov8" title="1">{
        return "help"
}</span>

func (c *HelpCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        // Updated map to include usage for each command
        <span class="cov8" title="1">commands := map[string][2]string{
                
                "cd":      {"change your directory", "cd &lt;path&gt;"},
                "ls":      {"see the content of the directory", "ls [options]"},
                "cat":     {"see the content of the files", "cat &lt;filename&gt;"},
                "pwd":     {"current directory path", "pwd"},
                "type":    {"type of a command", "type &lt;command&gt;"},
                "adduser": {"register user to shell", "adduser {username} {password | empty}"},
                "echo":    {"write text/variables to output", "echo &lt;text&gt;"},
                "login":   {"login to shell as user", "login {username} {password | empty}"},
                "logout":  {"logout the shell", "logout"},
                "exit":    {"exit the shell", "exit [status code]"},
                "color":   {"set on/off color mode", "color [on|off]"},
                "history": {"history of executed commands", "history | history clean"},
        }

        fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        // Adding the new "Usage" header
        coloredCommand := utils.ColorText("Command", utils.TextBlue, utils.Bold)
        coloredDescription := utils.ColorText("Description", utils.TextBlue, utils.Bold)
        coloredUsage := utils.ColorText("Usage", utils.TextBlue, utils.Bold)
        // Format now includes the "Usage" column
        fmt.Fprintf(stdout, "|   %s   |             %s           |           %s                       |\n", coloredCommand, coloredDescription, coloredUsage)
        fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        for key, val := range commands </span><span class="cov8" title="1">{
                coloredKey := utils.ColorText(key, utils.TextYellow)
                // The third element (val[1]) is the "Usage" information
                fmt.Fprintf(stdout, "| %-20s | %-42s | %-46s |\n", coloredKey, utils.ColorText(val[0], utils.TextMagenta), utils.ColorText(val[1], utils.TextCyan))
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(stdout, "-------------------------------------------------------------------------------------------")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package history

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type HistoryCommand struct {
        builtinHistory *map[string]int
        user           *user.User
        db             *gorm.DB
}

func NewHistoryCommand(builtinHistory *map[string]int, user *user.User, db *gorm.DB) *HistoryCommand <span class="cov8" title="1">{
        return &amp;HistoryCommand{
                builtinHistory: builtinHistory,
                user:           user,
                db:             db,
        }
}</span>

func (h *HistoryCommand) Name() string <span class="cov8" title="1">{
        return "history"
}</span>

func (h *HistoryCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">if len(args) == 1 </span><span class="cov8" title="1">{
                if args[0] != "clean" </span><span class="cov8" title="1">{
                        return utils.ErrInvalidArgs
                }</span>
                <span class="cov8" title="1">if h.user.Username != "" </span><span class="cov8" title="1">{
                        h.user.HistoryMap = map[string]int{}
                        err := user.Update(h.db, h.user)
                        return err
                }</span>
                <span class="cov8" title="1">*h.builtinHistory = map[string]int{}
                return nil</span>
        }
        <span class="cov8" title="1">if h.user.Username != "" </span><span class="cov8" title="1">{
                if len(h.user.HistoryMap) == 0 </span><span class="cov8" title="1">{
                        return utils.ErrEmptyHistory
                }</span>
                <span class="cov8" title="1">utils.PrintSortedMap(h.user.HistoryMap, stdout)
                return nil</span>
        }
        <span class="cov8" title="1">if len(*h.builtinHistory) == 0 </span><span class="cov8" title="1">{
                return utils.ErrEmptyHistory
        }</span>
        <span class="cov8" title="1">utils.PrintSortedMap(*h.builtinHistory, stdout)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package login

import (
        userService "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type LoginCommand struct {
        db   *gorm.DB
        user *userService.User
}

func NewLoginCommand(db *gorm.DB, user *userService.User) *LoginCommand <span class="cov8" title="1">{
        return &amp;LoginCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *LoginCommand) Name() string <span class="cov8" title="1">{
        return "login"
}</span>

func (c *LoginCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        // if (*c.user).Username != "" {
        //         return ErrLoggedin
        // }
        if len(args) == 0 </span><span class="cov8" title="1">{
                return utils.ErrUsernameRequired
        }</span>
        <span class="cov8" title="1">if len(args) &gt; 2 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>
        <span class="cov8" title="1">var pass string
        if len(args) == 2 </span><span class="cov8" title="1">{
                pass = args[1]
        }</span>
        <span class="cov8" title="1">user, err := userService.GetUser(c.db, args[0], pass)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if c.user.Username != "" </span><span class="cov0" title="0">{
                err := userService.Update(c.db, c.user)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">(*c.user).ID = user.ID
        (*c.user).Username = user.Username
        (*c.user).Password = user.Password
        (*c.user).History = user.History
        (*c.user).HistoryMap = user.HistoryMap

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package logout

import (
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "io"

        "gorm.io/gorm"
)

type LogoutCommand struct {
        db   *gorm.DB
        user *user.User
}

func NewLogoutCommand(db *gorm.DB, user *user.User) *LogoutCommand <span class="cov8" title="1">{
        return &amp;LogoutCommand{
                db:   db,
                user: user,
        }
}</span>

func (c *LogoutCommand) Name() string <span class="cov8" title="1">{
        return "logout"
}</span>

func (c *LogoutCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                return utils.ErrInvalidArgs
        }</span>

        <span class="cov8" title="1">err := user.Update(c.db, c.user)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">(*c.user).ID = 0
        (*c.user).Username = ""
        (*c.user).Password = ""

        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ls

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "io/fs"
        "os"
        "strings"
        "time"
)

// LSCommand implements the 'ls' built-in command
type LSCommand struct {
        showAll    bool
        longFormat bool
}

// NewLSCommand creates a new ls command
func NewLSCommand() *LSCommand <span class="cov8" title="1">{
        return &amp;LSCommand{}
}</span>

// Name returns the name of the command
func (c *LSCommand) Name() string <span class="cov0" title="0">{
        return "ls"
}</span>

// Execute handles the ls command execution
func (c *LSCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        // Parse arguments and options
        dirPath, err := c.parseArgs(args)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // If no directory specified, use current directory
        <span class="cov8" title="1">if dirPath == "" </span><span class="cov8" title="1">{
                dirPath = "."
        }</span>

        <span class="cov8" title="1">return c.listDirectory(dirPath, stdout)</span>
}

// parseArgs processes command line arguments and returns the target directory
func (c *LSCommand) parseArgs(args []string) (string, error) <span class="cov8" title="1">{
        var dirPath string
        c.showAll = false
        c.longFormat = false
        for _, arg := range args </span><span class="cov8" title="1">{
                if strings.HasPrefix(arg, "-") </span><span class="cov8" title="1">{
                        // Process options
                        for _, opt := range arg[1:] </span><span class="cov8" title="1">{
                                switch opt </span>{
                                case 'a':<span class="cov8" title="1">
                                        c.showAll = true</span>
                                case 'l':<span class="cov8" title="1">
                                        c.longFormat = true</span>
                                default:<span class="cov8" title="1">
                                        return "", fmt.Errorf("invalid option: %c", opt)</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        // Process directory path
                        if dirPath != "" </span><span class="cov8" title="1">{
                                return "", utils.ErrTooManyArgs
                        }</span>
                        <span class="cov8" title="1">dirPath = arg</span>
                }
        }

        <span class="cov8" title="1">return dirPath, nil</span>
}

// listDirectory lists the contents of the specified directory
func (c *LSCommand) listDirectory(dirPath string, stdout io.Writer) error <span class="cov8" title="1">{
        entries, err := os.ReadDir(dirPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot open directory %s: %v", dirPath, err)
        }</span>

        // Sort entries (optional, as ReadDir returns sorted entries by default)
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                // Skip hidden files unless -a flag is set
                if !c.showAll &amp;&amp; strings.HasPrefix(entry.Name(), ".") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if c.longFormat </span><span class="cov8" title="1">{
                        if err := c.printLongFormat(entry, stdout); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        fmt.Fprintln(stdout, entry.Name())
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// printLongFormat prints detailed file information
func (c *LSCommand) printLongFormat(entry fs.DirEntry, stdout io.Writer) error <span class="cov8" title="1">{
        info, err := entry.Info()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting info for %s: %v", entry.Name(), err)
        }</span>

        // Format: permissions size modified_time name
        <span class="cov8" title="1">mode := info.Mode().String()
        size := info.Size()
        modTime := info.ModTime().Format(time.RFC3339[:19]) // Use shorter time format
        name := entry.Name()
        fmt.Fprintf(stdout, "%s %8d %s %s\n", mode, size, modTime, name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package pwd

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "runtime"
        // "runtime"
)

type PwdCommand struct{}

func NewPwdCommand() *PwdCommand <span class="cov8" title="1">{
        return &amp;PwdCommand{}
}</span>

func (c *PwdCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        pwd, err := c.getCurrentDirectory()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current directory: %v", err)
        }</span>

        <span class="cov8" title="1">_, err = fmt.Fprintln(stdout, pwd)
        return err</span>
}

func (c *PwdCommand) getCurrentDirectory() (string, error) <span class="cov8" title="1">{

        if pwd, err := filepath.Abs("."); pwd != "" &amp;&amp; err == nil </span><span class="cov8" title="1">{
                if utils.IsValidDirectory(pwd) </span><span class="cov8" title="1">{
                        return filepath.Clean(pwd), nil
                }</span>
        }
        // Try /proc/self/cwd on Linux
        <span class="cov0" title="0">if runtime.GOOS == "linux" </span><span class="cov0" title="0">{
                if pwd, err := os.Readlink("/proc/self/cwd"); err == nil </span><span class="cov0" title="0">{
                        if utils.IsValidDirectory(pwd) </span><span class="cov0" title="0">{
                                return filepath.Clean(pwd), nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return "", nil</span>
}

func (c *PwdCommand) Name() string <span class="cov8" title="1">{
        return "pwd"
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package typecmd

import (
        "asa/shell/utils"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
)

type TypeCommand struct {
        builtins map[string]bool // Map of built-in commands
}

func NewTypeCommand(builtins []string) *TypeCommand <span class="cov8" title="1">{
        // Create a map of built-in commands for efficient lookup
        builtinsMap := make(map[string]bool)
        for _, cmd := range builtins </span><span class="cov8" title="1">{
                builtinsMap[cmd] = true
        }</span>

        <span class="cov8" title="1">return &amp;TypeCommand{
                builtins: builtinsMap,
        }</span>
}

func (c *TypeCommand) Name() string <span class="cov0" title="0">{
        return "type"
}</span>

func (c *TypeCommand) Execute(args []string, stdout io.Writer) error <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return utils.ErrMissingCommandName
        }</span>
        <span class="cov8" title="1">for _, cmd := range args </span><span class="cov8" title="1">{
                result, err := c.findCommand(cmd)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(stdout, result)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *TypeCommand) findCommand(cmd string) (string, error) <span class="cov8" title="1">{
        // Check if it's a built-in command
        if c.builtins[cmd] </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s is a shell builtin", cmd), nil
        }</span>

        // If not built-in, search in PATH
        <span class="cov8" title="1">path := os.Getenv("PATH")
        if path == "" </span><span class="cov8" title="1">{
                return "", utils.ErrEnvironmentVarNotSet
        }</span>

        // Search in each directory in PATH
        <span class="cov8" title="1">dirs := strings.Split(path, ":")
        for _, dir := range dirs </span><span class="cov8" title="1">{
                fullPath := filepath.Join(dir, cmd)
                if fileInfo, err := os.Stat(fullPath); err == nil </span><span class="cov8" title="1">{
                        // Check if the file is executable
                        if fileInfo.Mode()&amp;0111 != 0 </span><span class="cov8" title="1">{

                                return fmt.Sprintf("%s is %s", cmd, fullPath), nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return "", utils.ErrCommandNotFound</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "fmt"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

const (
        dbHost = "localhost"
        dbPort = "5432"
        dbName = "postgres"
        dbUser = "postgres"
        dbPass = "postgres"
)

var db *gorm.DB

func init() <span class="cov8" title="1">{
        dsn := fmt.Sprintf("host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
                dbHost, dbPort, dbName, dbUser, dbPass)

        sesssion, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)})
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("unable to connect to database: %w", err)
                panic(err)</span>
        }

        <span class="cov8" title="1">db = sesssion</span>

}

func GetDB() *gorm.DB <span class="cov8" title="1">{
        return db
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package redirection

import (
        "fmt"
        "os"
)

type RedirectionType int

var (
        ErrMissingFileForRedirection = fmt.Errorf("missing file for redirection")
)

const (
        NoRedirection  RedirectionType = iota
        OutputRedirect                 // &gt;
        OutputAppend                   // &gt;&gt;
        ErrorRedirect                  // 2&gt;
        ErrorAppend                    // 2&gt;&gt;
)

type Redirection struct {
        Type RedirectionType
        File string
}

func ParseRedirection(args []string) ([]string, *Redirection, error) <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return args, nil, nil
        }</span>
        <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                switch </span>{
                case arg == "&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov8" title="1">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: OutputRedirect,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: OutputRedirect,
                                File: args[i+1],
                        }, nil</span>

                case arg == "&gt;&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: OutputAppend,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: OutputAppend,
                                File: args[i+1],
                        }, nil</span>

                case arg == "2&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: ErrorRedirect,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: ErrorRedirect,
                                File: args[i+1],
                        }, nil</span>

                case arg == "2&gt;&gt;":<span class="cov8" title="1">
                        if i+1 &gt;= len(args) </span><span class="cov8" title="1">{
                                return nil, nil, ErrMissingFileForRedirection
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                                        return args, nil, ErrMissingFileForRedirection
                                }</span>
                                <span class="cov8" title="1">return args[3:], &amp;Redirection{
                                        Type: ErrorAppend,
                                        File: args[1],
                                }, nil</span>
                        }
                        <span class="cov8" title="1">return args[:i], &amp;Redirection{
                                Type: ErrorAppend,
                                File: args[i+1],
                        }, nil</span>
                }
        }

        <span class="cov8" title="1">return args, nil, nil</span>
}

func SetupRedirection(redir *Redirection) (*os.File, error) <span class="cov8" title="1">{
        if redir == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">flags := os.O_WRONLY | os.O_CREATE
        if redir.Type == OutputAppend || redir.Type == ErrorAppend </span><span class="cov8" title="1">{
                flags |= os.O_APPEND
        }</span> else<span class="cov8" title="1"> {
                flags |= os.O_TRUNC
        }</span>
        <span class="cov8" title="1">file, err := os.OpenFile(redir.File, flags, 0644)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open redirection file: %v", err)
        }</span>
        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        "encoding/json"
        "errors"
        "fmt"

        "gorm.io/gorm"
)

var (
        ErrNoUserFound      = errors.New("no user found")
        ErrUserShouldntNill = errors.New("user cannot be nil")
        ErrUserNameRequired = errors.New("username is required")
        ErrWrongPassword    = errors.New("wrong password")
        ErrDuplicateUser    = errors.New("duplicate user exists with this username")
        ErrUserNotFound     = errors.New("user not found")
        ErrPassRequired     = errors.New("password required")
)

func RegisterUser(db *gorm.DB, user *User) error <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                return errors.New("user cannot be nil")
        }</span>

        <span class="cov8" title="1">if err := validate(user); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation error: %w", err)
        }</span>

        <span class="cov8" title="1">var existingUser User
        err := db.Where("user_name = ?", user.Username).First(&amp;existingUser).Error
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                return ErrDuplicateUser
        }</span>

        <span class="cov8" title="1">historyMap := map[string]int{}

        historyJSON, err := json.Marshal(historyMap)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode history to JSON: %w", err)
        }</span>
        <span class="cov8" title="1">user.History = string(historyJSON)

        if err := db.Create(user).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert user into database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func GetUser(db *gorm.DB, username string, password string) (User, error) <span class="cov8" title="1">{
        var user User
        if err := db.Where("user_name = ? ", username).First(&amp;user).Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return user, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return user, err</span>
        }
        <span class="cov8" title="1">if user.Password != "" &amp;&amp; user.Password != password </span><span class="cov8" title="1">{
                if password == "" </span><span class="cov8" title="1">{
                        return user, ErrPassRequired
                }</span>
                <span class="cov8" title="1">return user, ErrWrongPassword</span>
        }

        <span class="cov8" title="1">var historyMap map[string]int
        err := json.Unmarshal([]byte(user.History), &amp;historyMap)
        if err != nil </span><span class="cov0" title="0">{
                historyMap = map[string]int{}
                user.HistoryMap = historyMap
                return user, err
        }</span>
        <span class="cov8" title="1">user.HistoryMap = historyMap

        return user, nil</span>
}

func Update(db *gorm.DB, user *User) (err error) <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                return ErrUserShouldntNill
        }</span>
        <span class="cov8" title="1">if err := validate(user); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("validation error: %w", err)
        }</span>
        <span class="cov8" title="1">historyJSON, err := json.Marshal(user.HistoryMap)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode history to JSON: %w", err)
        }</span>
        <span class="cov8" title="1">user.History = string(historyJSON)
        err = db.Save(user).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user in database: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validate(user *User) (err error) <span class="cov8" title="1">{
        if user.Username == "" </span><span class="cov8" title="1">{
                return ErrUserNameRequired
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package shell

import (
        "asa/shell/internal/command"
        "asa/shell/internal/command/adduser"
        "asa/shell/internal/command/cat"
        "asa/shell/internal/command/cd"
        "asa/shell/internal/command/color"
        "asa/shell/internal/command/echo"
        "asa/shell/internal/command/exit"
        "asa/shell/internal/command/help"
        "asa/shell/internal/command/history"
        "asa/shell/internal/command/login"
        "asa/shell/internal/command/logout"
        "asa/shell/internal/command/ls"
        "asa/shell/internal/command/pwd"
        typecmd "asa/shell/internal/command/type"
        db "asa/shell/internal/database"
        "asa/shell/internal/redirection"
        user "asa/shell/internal/service"
        "asa/shell/utils"
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "strings"

        "gorm.io/gorm"
)

var (
        ErrCommandNotSupported = errors.New("command not found")
        ErrNotValidDirectory   = errors.New("current directory is not valid")
)

type Shell struct {
        reader   *bufio.Reader
        user     user.User
        database *gorm.DB
        commands map[string]command.Command
        history  map[string]int
        rootDir  string
}

type std struct {
        std          *os.File
        isRedirected bool
}
type redirect struct {
        stdout    *std
        stderr    *std
        redirType redirection.RedirectionType
}

func New() *Shell <span class="cov8" title="1">{
        rootDir, err := utils.CurrentPwd()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Shell{}
        }</span>

        <span class="cov8" title="1">err = db.GetDB().AutoMigrate(&amp;user.User{})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error migrating database:", err)
        }</span>

        <span class="cov8" title="1">sh := &amp;Shell{
                user:     user.User{Username: ""},
                database: db.GetDB(),
                reader:   bufio.NewReader(os.Stdin),
                commands: make(map[string]command.Command),
                history:  make(map[string]int),
                rootDir:  rootDir,
        }
        exitCmd := exit.NewExitCommand(sh.database, &amp;sh.user)
        sh.registerCommand(exitCmd)

        echoCmd := echo.NewEchoCommand()
        sh.registerCommand(echoCmd)

        catCmd := cat.NewCatCommand()
        sh.registerCommand(catCmd)

        pwdCmd := pwd.NewPwdCommand()
        sh.registerCommand(pwdCmd)

        cdCmd := cd.NewCDCommand(sh.rootDir)
        sh.registerCommand(cdCmd)

        lsCmd := ls.NewLSCommand()
        sh.commands[lsCmd.Name()] = lsCmd

        colorCmd := color.NewColorCommand()
        sh.commands[colorCmd.Name()] = colorCmd

        loginCmd := login.NewLoginCommand(sh.database, &amp;sh.user)
        sh.commands[loginCmd.Name()] = loginCmd

        adduserCmd := adduser.NewAddUserCommand(sh.database, &amp;sh.user)
        sh.commands[adduserCmd.Name()] = adduserCmd

        logoutCmd := logout.NewLogoutCommand(sh.database, &amp;sh.user)
        sh.commands[logoutCmd.Name()] = logoutCmd

        historyCmd := history.NewHistoryCommand(&amp;sh.history, &amp;sh.user, sh.database)
        sh.commands[historyCmd.Name()] = historyCmd

        helpCmd := help.NewHelpCommand()
        sh.commands[helpCmd.Name()] = helpCmd

        shellBuiltins := []string{}
        for cmd := range sh.commands </span><span class="cov8" title="1">{
                shellBuiltins = append(shellBuiltins, cmd)
        }</span>
        <span class="cov8" title="1">typeCmd := typecmd.NewTypeCommand(shellBuiltins)
        sh.registerCommand(typeCmd)

        stdout := &amp;bytes.Buffer{}
        sh.commands["pwd"].Execute([]string{}, stdout)
        sh.rootDir = stdout.String()

        // if err := utils.ClearAndFillHistoryWithMockData(sh.database); err != nil {
        //         log.Fatalf("Error clearing and filling history: %v", err)
        // }
        return sh</span>
}

func (s *Shell) registerCommand(cmd command.Command) <span class="cov8" title="1">{
        s.commands[cmd.Name()] = cmd
}</span>

func (s *Shell) Start() error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if err := s.printPrompt(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">input, err := s.readInput()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if input == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if stderr, err := s.executeCommand(input); err != nil </span><span class="cov0" title="0">{
                        if stderr.isRedirected </span><span class="cov0" title="0">{
                                defer stderr.std.Close()
                        }</span>
                        <span class="cov0" title="0">cmdError := fmt.Sprintf("%s: %v\n", input, err)
                        if utils.IsColor() </span><span class="cov0" title="0">{
                                cmdError = utils.ColorText(cmdError, utils.TextRed)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(stderr.std, "%s", cmdError)
                        if err == ErrCommandNotSupported </span><span class="cov0" title="0">{
                                fmt.Println()
                                fmt.Fprintln(stderr.std, "List of supported builtin commands are as followings: ")
                                for key := range s.commands </span><span class="cov0" title="0">{
                                        fmt.Fprintln(stderr.std, key)
                                }</span>
                        }
                }
        }
}

// printPrompt displays the shell prompt
func (s *Shell) printPrompt() error <span class="cov0" title="0">{
        currentDir, err := utils.CurrentPwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">addr := utils.HandleAdress(s.rootDir, currentDir)
        user := s.user.Username
        if utils.IsColor() </span><span class="cov0" title="0">{
                addr = utils.ColorText(addr, utils.TextBlue)
                user = utils.ColorText(s.user.Username, utils.TextGreen)
        }</span>
        <span class="cov0" title="0">if s.user.Username != "" </span><span class="cov0" title="0">{
                _, err = fmt.Fprintf(os.Stdout, "%s:%s$ ", user, addr)
        }</span> else<span class="cov0" title="0"> {
                _, err = fmt.Fprintf(os.Stdout, "%s$ ", addr)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (s *Shell) readInput() (string, error) <span class="cov8" title="1">{
        input, err := s.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(input), nil</span>
}

func (s *Shell) executeCommand(input string) (*std, error) <span class="cov8" title="1">{
        cmd, args, redirects, err := s.parseCommand(input)
        if cmd != "history" </span><span class="cov8" title="1">{
                if s.user.Username != "" </span><span class="cov0" title="0">{
                        s.user.HistoryMap[input]++
                        // err := user.Update(s.database, &amp;s.user) // too insufficient but most reliable
                }</span> else<span class="cov8" title="1"> {
                        s.history[input]++
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return redirects.stderr, err
        }</span>

        <span class="cov8" title="1">if redirects.stdout.isRedirected </span><span class="cov0" title="0">{

                defer redirects.stdout.std.Close()
        }</span>

        <span class="cov8" title="1">if command, exists := s.commands[cmd]; exists </span><span class="cov8" title="1">{
                err := command.Execute(args, redirects.stdout.std)
                if err != nil </span><span class="cov0" title="0">{
                        return redirects.stderr, err
                }</span>
                <span class="cov8" title="1">return redirects.stderr, nil</span>
        }

        <span class="cov8" title="1">if err := s.executeSystemCommand(cmd, args, redirects.stdout.std, redirects.stderr.std); err != nil </span><span class="cov8" title="1">{
                return redirects.stderr, ErrCommandNotSupported
        }</span>

        <span class="cov8" title="1">return redirects.stderr, nil</span>
}

func (s *Shell) executeSystemCommand(name string, args []string, stdout io.Writer, stderr io.Writer) error <span class="cov8" title="1">{
        execPath, err := utils.FindCommand(name)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if utils.HasPrefix(execPath, "$builtin") </span><span class="cov0" title="0">{
                execPath = strings.Split(execPath, ":")[1]
        }</span>

        <span class="cov8" title="1">cmd := exec.Command(execPath, args...)

        cmd.Stdout = stdout
        cmd.Stderr = stderr

        err = cmd.Run()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to execute %s: %v", name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Shell) parseCommand(input string) (string, []string, *redirect, error) <span class="cov8" title="1">{
        redirects := &amp;redirect{stdout: &amp;std{os.Stdout, false}, stderr: &amp;std{os.Stderr, false}}
        parsedArg, err1 := utils.ParseArgs(input)
        if err1 != nil </span><span class="cov0" title="0">{
                return "", nil, redirects, nil
        }</span>
        <span class="cov8" title="1">if len(parsedArg) == 0 </span><span class="cov8" title="1">{
                return "", nil, redirects, nil
        }</span>
        // Parse redirection
        <span class="cov8" title="1">args, redir, err := redirection.ParseRedirection(parsedArg)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, redirects, err
        }</span>
        // Setup redirection if needed
        <span class="cov8" title="1">if redir != nil </span><span class="cov8" title="1">{
                file, err := redirection.SetupRedirection(redir)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, redirects, err
                }</span>
                // Set appropriate output &amp; error
                <span class="cov8" title="1">switch redir.Type </span>{
                case redirection.OutputRedirect, redirection.OutputAppend:<span class="cov8" title="1">
                        redirects.stdout.std = file
                        redirects.stdout.isRedirected = true</span>
                case redirection.ErrorRedirect, redirection.ErrorAppend:<span class="cov8" title="1">
                        redirects.stderr.std = file
                        redirects.stderr.isRedirected = true</span>
                }
                <span class="cov8" title="1">redirects.redirType = redir.Type</span>
        }
        // for case : &gt; file3 cat file2
        <span class="cov8" title="1">if parsedArg[0][0] != '&gt;' &amp;&amp; parsedArg[0][0] != '2' </span><span class="cov8" title="1">{
                return parsedArg[0], args[1:], redirects, err1
        }</span> else<span class="cov8" title="1"> {
                return parsedArg[2], args, redirects, err1
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
